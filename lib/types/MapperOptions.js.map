{"version":3,"file":"MapperOptions.js","sourceRoot":"","sources":["../../src/types/MapperOptions.ts"],"names":[],"mappings":"","sourcesContent":["import { OnlySideEffect, SettledResult } from '.';\n\n/** @public */\n\n/*\n\nMapper<T = any, U = unknown, A = T> = ;\n= Mapper<T, Promise<U>, T | Settled<T>>;\n\n */\nexport interface TransformFn<T, U = unknown> {\n  (\n    value: T,\n    index: number,\n    array: readonly (T | PromiseSettledResult<T>)[]\n  ): Promise<U>;\n}\n/** @public */\nexport interface LookupFn<S, U = unknown> {\n  (\n    value: U,\n    index: number,\n    array: readonly (S | PromiseSettledResult<S>)[]\n  ): OnlySideEffect;\n}\n/** @public */\nexport interface ValidateFn<S, U = unknown> {\n  (\n    value: U,\n    index: number,\n    array: readonly (S | PromiseSettledResult<S>)[]\n  ): Promise<OnlySideEffect>;\n}\n/** @public  */\nexport interface ErrLookupFn {\n  /**\n   * @param  reason - The reason provided by the catch clause\n   * inside the mapping routine.\n   * @param index - The zero based index provided by map or\n   * similarly an index provided by the mapping routine.\n   * @param currentRejection - Flag that indicates if the exception\n   * was hapening on the curent iteration of the mapping routine or\n   * if it was part of a previously raised exception that was already\n   * part of the item currently being mapped from the ptovided collection.\n   * @returns Do not return any value is trigered syncrounously.\n   */\n  (reason: any, index: number, currentRejection: boolean): OnlySideEffect;\n}\n\n/** @internal */\nexport interface MapperOptions<T, U = unknown> {\n  item: T | SettledResult<T>; //  | PromiseLike<T | SettledResult<T>>;\n  index: number;\n  array: (T | PromiseSettledResult<T>)[];\n  transform?: TransformFn<T, U>;\n  lookup?: LookupFn<T, U>;\n  validate?: ValidateFn<T, U>;\n  errLookup?: ErrLookupFn;\n}\n"]}